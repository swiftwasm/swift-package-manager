/*
 This source file is part of the Swift.org open source project

 Copyright (c) 2021 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors
 */

/// Provides information about the target being built, as well as contextual
/// information such as the paths of the directories to which commands should
/// be configured to write their outputs. This information should be used as
/// part of generating the commands to be run during the build.
public final class TargetBuildContext: Decodable {
    
    /// The name of the target being built, as specified in the manifest.
    public let targetName: String

    /// The module name of the target. This is currently derived from the name,
    /// but could be customizable in the package manifest in a future SwiftPM
    /// version.
    public let moduleName: String

    /// The path of the target source directory.
    public let targetDirectory: Path

    /// That path of the package that contains the target.
    public let packageDirectory: Path

    /// Information about the input files specified in the target being built,
    /// including the sources, resources, and other files. This sequence also
    /// includes any source files generated by other plugins that are listed
    /// earlier than this plugin in the `plugins` parameter of the target
    /// being built.
    public let inputFiles: FileList

    /// Information about all targets in the dependency closure of the target
    /// to which the plugin is being applied. This list is in topologically
    /// sorted order, with immediate dependencies appearing earlier and more
    /// distant dependencies later in the list. This is mainly intended for
    /// generating lists of search path arguments, etc.
    public let dependencies: [DependencyTargetInfo]

    /// Provides information about a target that appears in the dependency
    /// closure of the target to which the plugin is being applied.
    public struct DependencyTargetInfo: Decodable {

        /// The name of the target.
        public let targetName: String

        /// The module name of the target. This is currently derived from the
        /// name, but could be customizable in the package manifest in a future
        /// SwiftPM version.
        public let moduleName: String

        /// Path of the target source directory.
        public let targetDirectory: Path

        /// Path of the public headers directory, if any (Clang targets only).
        public let publicHeadersDirectory: Path?
    }

    /// The path of a writable directory into which the plugin or the build
    /// commands it constructs can write anything it wants. This could include
    /// any generated source files that should be processed further, and it
    /// could include any caches used by the build tool or the plugin itself.
    /// The plugin is in complete control of what is written under this di-
    /// rectory, and the contents are preserved between builds.
    ///
    /// A plugin would usually create a separate subdirectory of this directory
    /// for each command it creates, and the command would be configured to
    /// write its outputs to that directory. The plugin may also create other
    /// directories for cache files and other file system content that either
    /// it or the command will need.
    public let pluginWorkDirectory: Path

    /// The path of the directory into which built products associated with
    /// the target are written.
    public let builtProductsDirectory: Path

    /// Looks up and returns the path of a named command line executable tool.
    /// The executable must be provided by an executable target or a binary
    /// target on which the package plugin target depends. This function throws
    /// an error if the tool cannot be found. The lookup is case sensitive.
    public func tool(named name: String, line: UInt = #line) throws -> Tool {
        if let tool = self.tools[name] { return tool }
        throw TargetBuildContextError.toolNotFound(name: name, line: line)
    }

    /// A mapping from tool names to their definitions. Not directly available
    /// to the plugin but used by the `tool(named:)` API.
    private let tools: [String: Tool]
    
    /// Information about a particular tool that is available to a plugin.
    public struct Tool: Codable {
        
        /// Name of the tool, suitable for display purposes.
        public let name: String

        /// Path of the built or provided tool in the file system.
        public let path: Path
    }
}

public enum TargetBuildContextError: Error {
    
    /// Could not find a tool with the given name. This could be either because
    /// it doesn't exist, or because the plugin doesn't have a dependency on it.
    case toolNotFound(name: String, line: UInt)
}

extension TargetBuildContextError: CustomStringConvertible {
    
    public var description: String {
        switch self {
        case .toolNotFound(let name, let line):
            // FIXME: How to convey this line number to where it gets shown for errors at top level.
            // Need to customize "Fatal error: Error raised at top level: plugin doesn’t have access to any tool named ‘MySourceGenBuildTools’ [5]: file Swift/ErrorType.swift, line 200"
            return "plugin doesn’t have access to any tool named ‘\(name)’ [line \(line)]"
        }
    }
}
